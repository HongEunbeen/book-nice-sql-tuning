## 테이블 액세스 최소화

SQL 튜닝은 랜덤 I/O와의 전쟁입니다.

### [파티셔닝]

```
파티셔닝
- 매우 큰 테이블을 여러 개의 작은 부부능로 나누는 데이터베이스 프로세스
- 대형 테이블의 유지 관리를 지원하고 SQL 작업에 대한 데이터 읽기 및 로드에 대한 응답 시간을 줄이는 것이 목표
```

파티셔닝은 물리적으로 분리해 I/O 경합을 낮추는 것을 목적으로 합니다.

### [ROWID]

```
ROWID
- 테이블 레코드를 찾아가기 위한 논리적 주소 정보값
- 디스크 상에서 테이블 레코드를 찾아가기 위한 위치 정보를 담고 있음(논리적)
```

인덱스를 스캔하는 이유는 소량의 데이터를 인덱스에서 빨리 찾고 ROWID를 얻으려는데 있습니다.

### [메인 메모리 DB와 비교]

```
메인 메모리 DB
- 데이터를 모두 메모리에 로드해 놓고 메모리를 통해서만 I/O를 수행하는 DB
```

메인 메모리 DB와 다르게 오라클은 테이블 블록이 수시로 버퍼캐시에서 밀력 났다가, 다시 캐싱되며, 다른 공간에 캐싱됩니다.

즉, 오라클은 인덱스에서 포인터로 메모리 주소 정보를 연결할 수 없는 주고여서 디스크 주소 정보를 이용해 해시 알고리즘으로 버퍼 블록을 찾아갑니다.

### [I/O 매커니즘]

1. 블록을 읽기 전 버퍼 캐시부터 찾아좀
2. DBA(디스크 주소 정보)를 해시 함수에 입력
3. 해시 함수는 DBA를 이용해 해시 체인을 찾고 거기서 버퍼 헤더를 찾음
    
    → 버퍼 헤더는 항상 같은 해시 체인에 연결됩니다.
    

정리 : 해싱 알고리즘으로 버퍼 헤더를 찾고, 거기서 얻은 포인터로 버퍼 블록을 찾아갑니다.

이렇게 테이블 블록을 버퍼 캐시에서 먼저 찾아본 후 없으면 디스크에서 블록을 새로 읽습니다.

### [인덱스 ROWID]

```
ROWID 
- 디스크 상에서 테이블 레코드를 찾아가기 위한 논리적인 주소 정보
```

ROWID를 이용한 테이블 액세스는 생각보다 고비용 구조 입니다.

데이터가 캐싱돼 있더라도 테이블 레코드를 찾기 위해 매번 DBA 해싱과 래치 획득 과정을 반복해야 합니다.

### [인덱스 클러스터링 팩터(CF)]

```
클러스터링 팩터(CF)
- 특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도를 의미합니다.
```

CF가 좋은 컬럼에 생성한 인덱스는 테이블 액세스량에 비해 블록 I/O가 적게 발생하여 검색 효율이 매우 좋습니다.

CF가 좋은 상태는 인덱스 레코드의 정렬 순서와 테이블 레코드 정렬 순서가 100% 일치합니다.

즉, CF가 좋은 증거는 인덱스 정렬순서와 테이블 정렬 순서의 일치 여부입니다.

인덱스 CF가 나쁘면 같은 테이블 블록을여러번 반복 액세스합니다.

- 논리적 I/O 횟수가 늘어납니다.
- 물리적 I/O횟수가 늘어납니다.

### [인덱스 손익분기점]

```
인덱스 손익분기점
- Index Range Scan에 의한 테이블 액세스가 Table Full Scan보다 노려지는 지점
```

인덱스 ROWID는 고비용이기에 읽어야 할 데이터가 일정량을 넘어가면, 테이블 전체를 스캔하는 것보다 느려집니다.

Tabel Full Scan은 성능이 일정합니다. 하지만 Index는 랜덤 액세스를 하기 때문에 성능이 일정하지 않습니다. 

인덱스 손익분기점 발생 요인이 두 가지가 있습니다.

- Table Full Scan은 시퀀셜 액세스 : Index Scan은 랜덤 액세스
- Table Full Scan은 Multiblock I/O : index Scan은 Single Block I/O

### [온라인 프로그램 튜닝 vs 배치 프로그램 튜닝]

- 온라인 프로그램 : 소량의 데이터를 읽고 갱신하므로 인덱스를 효과적으로 활용하는 것이 중요합니다.
- 배치 프로그램 : 전체범위 처리 기준으로 튜닝해야 하기 때문에 Full Scan이 유리합니다.

### [튜닝1 - 인덱스 컬럼 추가]

인덱스 컬럼 추가 : 테이블액세스 최소화를 위해 가장 일반적으로 사용하는 튜닝입니다.

- 장점 : 기존 인덱스에 새로운 컬럼을 추가하는 것만으로 인덱스 스캔량은 줄지 않지만, 테이블 랜덤 액세스 횟수를 줄일 수 있습니다.
- 단점 : 테이블마다 인덱스가 수십 개씩 달릴 수 있습니다.

### [튜닝2 - Covered 쿼리]

테이블 랜덤 액세스가 많아도 필터 조건에 의해 버려지는 레코드가 없다면 비효율이 아닙니다.

즉, 절대 일량이 많아서 느린거는 어쩔 수 없지만 성능을 개선해야 할때는, 쿼리에 사용된 컬럼을 모두 인덱스에 추가해 테이블 액세스가 아예 발생하지 않게 할 수 있습니다.

```
Covered 쿼리
- 인덱스만 읽어서 처리하는 쿼리로 해당 쿼리에 사용한 인덱스를 Covered 인덱스라고 부릅니다.
```

- 장점 : 매우 효과적입니다.
- 단점 : 추가해야 할 컬럼이 많아 실제 적용하기 어렵습니다.

### [Include 인덱스]

```
Incloude 인덱스
- 인덱스 키 외에 미리 지정한 컬럼을 리프 레벨에 함께 저장하는 기능
- SQL Server 2005 버전에 존재
```

특정 컬럼을 리프 블록에 저장하면, 수평적 탐색에서도 해당 컬럼을 필터 조건으로 사용해 테이블 랜덤 액세스 횟루를 줄일는 용도로만 사요이 가능합니다.

include 인덱스는 순전히 테이블 랜덤 액세스를 줄이는 용도로 개발되었습니다.

### [인덱스 구조 테이블]

```
클러스터형 인덱스 / IOT
- 랜덤 액세스가 아예 발생하지 않도록 테이블을 인덱스 구조로 생성하는 방법
- 테이블 블록에 있어야 할 데이터를 인덱스 리프 블록에 모두 저장
- 인위적으로 클러스러링 팩터를 좋게 만드는 방법
```

인덱스 리프 블록 = 데이터 블록 개념입니다.

- 데이터 입력 : 일반 테이블은 랜덤방식으로 데이터 입력하지만 클러스터형 인덱스는 인덱스 구조 테이블이므로 정렬 상태를 유지하며 데이터를 입력합니다.
- 장점 : 같은 값을 가진 레코드들이 모여 있으므로 랜덤 액세스가 아닌 시퀀셜 데이터 액세스 사용
    - BETWEEN, 부등호 조건으로 넓은 범위 읽을 때 유리
    - 데이터 입력과 조회 패턴이 서로 다른 테이블에도 유용

### [클러스터 테이블]

```
클러스터 테이블
- 디스크로부터 데이터를 읽어오는 시간을 줄이기 위해 데이터를 디스크와 같은 위치에 저장하는 방법으로 테이블의 저장 구조를 개선
```

클러스터는 클러스터 캐싱을 높이기 위해 사용하고 파티셔닝은 물리적으로 분리해 I/O 경합을 줄이기 위해 사용합니다.

- 인덱스 클러스터 테이블
    
    ```
    인덱스 클러스터 테이블
    - 클러스터 키 값이 같은 레코드를 한 블록에 저장하는 구조
    - 한 블록에 모두 담을 수 없을 때는 새로운 블록을 할당해 클러스터 체인으로 연결
    ```
    
- 해시 클러스터 테이블
    
    ```
    해시 클러스터
    - 인덱스를 사용하지 않고 해시 알고리즘을 사용해 클러스터를 찾아가는 구조
    ```
    

### [인덱스 클러스터 테이블]

인덱스 레코드는 테이블 레코드와 1:1 대응 관계가 아닌 1:M 관계를 맺습니다. 따라서 클러스터 인덱스의 키값은 항상 Unique합니다.

즉, 값을 찾을 때 랜덤 댁세스가 값 하나당 한 번씩 밖에 발생하지 않습니다.

클러스터형 인덱스(iot)와 인덱스 클러스터 테이블은 다릅니다.

- 공통점 : 키 값이 같은 데이터를 같은 공간에 저장
- 차이점 : 클러스터형 인덱스는 정렬하지만 인덱스 클러스터 테이블은 정렬하지 않음

### [인덱스 클러스터 테이블 구성 방법]

1. 클러스터 생성
2. 클러스터 인덱스 정의
    - 클러스터 인덱스는 데이터 검색 용도로 사용할 뿐만 아니라 데이터가 저장될 위치를 찾을 때도 사용합니다.
    - 일반 B Tree 인덱스 구조를 사용하지만, 키 값을 저장하는 첫번째 블록을 가리킵니다.
3. 클러스터 테이블 생성

## 부분범위 처리 활용

랜덤 액세스로 인한 인덱스 손익분점의 한계를 극복하기 위해 부분범위 처리를 합니다.

### [부분범위 처리]

```
부분범위 처리
- 사용자로부터 Fetch Call이 있을 때마다 일정량씩 나누어 전송하는 것
- DBMS가 클라이언트에게 데이터를 전송할 떄 일정량씩 나누어 전송하는 방법
- 서버 프로세스는 클라이언트로부터 추가 Fetch Call을 받기 전까지 그대로 멈춰 서서 기다림
```

### [정렬조건의 부분범위 처리]

정렬조건이 존재할 때는 DB 서버는 모든 데이터를 다 읽은 후 정렬을 마치고 데이터를 클라이언트에게 전송할 수 있습니다.

즉, 전체범위 처리가 됩니다.

하지만 해당 컬럼이 선두인 인덱스가 있으면, 부분범위 처리가 가능합니다. (인덱스는 항상 정렬된 상태를 유지하기에 결과 집합을 바로 전송 가능)

### [Array Size 조정]

네트워크를 통해 전송해야 할 데이터량에 따라 Array Size를 조절하면 Fetch Call 최소화를 할 수 있습니다.

- 대량 데이터 : Array Size 값을 크게 설정해 Fetch Call 횟수를 줄입니다.
- 앞쪽 일부 데이터 : Array Size를 작게 설정해 Fetch 하다가 멈추어 비효율을 줄입니다.

### [OLTP 환경에서 부붐범위 처리에 의한 성능개선 원리]

```
OLTP(Online Transaction Processing)
- 온라인 트랜잭션을 처리하는 시스템
- 소량 데이터를 읽고 갱신
```

게시판 등 정렬상태를 유지하는 인덱스를 이용하면, 정렬 작업을 생략하고 앞쪽 일부 데이터를 빠르게 보여줄 수 있습니다.

## 인덱스 스캔 효율화

시스템 개발 단계에서는 물리 설계가 가장 중요합니다.

### [인덱스 탐색]

수직적 탐색은 스캔 시작점을 찾는 과정입니다.

즉, 조건절을 이용해 스캔 시작과 끝 지점을 결정하면 스캔량이 줄어듭니다.

### [인덱스 스캔 효율성]

인덱스 선행 컬럼이 조건절에 없거나 등치 조건이 아니면 인덱스 스캔 과정에 비효율이 발생합니다.

효율성 측정은 조건절 데이터를 일일이 조회해보거나, SQL 트레이스를 통해 알 수 있습니다.

### [액세스 조건과 필터 조건]

인덱스를 스캔하는 단계에서 처리하는 조건절입니다.

```
인덱스 액세스 조건
- 인덱스 스캔 범위를 결정하는 조건절

인덱스 필터 조건
- 테이블로 액세스할지 결정하는 조건절

테이블 필터 조건
- 쿼리 수행 다음 단계로 전달하거나 최종 결과집합에 포함할지를 결정하는 조건절
- 인덱스, 테이블 Full Scan모두 테이블 액세스 단계에서 처리되는 조건절은 모두 필터 조건
```

1. 인덱스 액세스 조건으로 인덱스 스캔 범위 결정
2. 인덱스 필터 조건으로 인덱스 스캔 중 테이블로 액세스할 데이터 블록 결정
3. 테이블 필터 조건으로 쿼리 수행 다음 단계로 전달하거나 최종 결과집합에 포함할지 결정
- 인덱스 액세스 조건 : 선행 컬럼이 모두 등치 조건인 상태에서 첫 번째 나타나는 범위 검색 조건까지
- 인덱스 필터 조건 : 인덱스 액세스 조건을 제외한 모든 인덱스 컬럼 조건

### [인덱스 선행 컬럼 조건에 대한 비효율]

인덱스 스캔 효율성은 인덱스 컬럼을 조건절에 모두 등치 조건으로 사용할 때가 가장 좋습니다.

하지만, 이럴때 인덱스 스캔 효율성이 떨어집니다.

- 인덱스 선행 컬럼이 조건절에 없음
- 인덱스 선행 컬럼이 등치 조건이 아닌 범위 검색 조건

→ 인덱스 선행 컬럼이 모두 등치 조건일 때  필요한 범위만 스캔하고 멈출 수 있는 이유는, 조건을 만족하는 레코드가 모두 한데 모여 있기 때문입니다.

### [인덱스 선행 컬럼 조건에 대한 비효율 극복 - BETWEEN을 IN-List로 전환(조건절 변경)]

운영 시스템에서 인덱스 구성을 바꾸기 어렵다면 BETWEEN 조건을 IN-List 조건으로 바꿔주면 됩니다.

IN-List 개수만큼 UNION ALL 브랜치가 생성되고 각 브랜치마다 모든 컬럼을 등치 조건으로 검색하므로 선두 컬럼에 BETWEEN을 사용할 때와 같은 비효율이 사라집니다.

주의할 점

- IN-List 개수가 많지 않아야 합니다.
- 인덱스 스캔 과정에 선택되는 레코드들이 서로 멀리 떨어져 있을 때만 유용합니다.

데이터 분포나 수직적 탐색 비용을 따져보지도 않고 BETWEEN을  IN-List로 변환해서는 안됩니다.

### [인덱스 선행 컬럼 조건에 대한 비효율 극복 - Index Skip Scan]

조건절을 변경하지 않고 Inex Scip Scan을 사용해 비효율을 줄일 수 있습니다.

### [IN 조건은 = 인가]

IN 조건은 등치 조건이 아닌 필터조건입니다.

IN 조건은 IN-LIst iterator 방식으로 푸는 것이 등치 조건입니다.

### [BETWEEN과 LIKE 스캔 범위]

개발자들은 LIKE로 코딩하는 것이 더 편리하기 때문에 LIKE를 더 많이 사용하지만 LIKE보다 BETWEEN을 사용하는게 좋습니다.

스캔 범위가 확연히 차이가 나기 때문입니다.

### [범위 검색 조건에 대한 비효율]

컬럼이 인덱스 구성 컬럼일때 LIKE를 쓰면 비효율적입니다.

또한, BETWEEN도 남용해서는 안됩니다.

인덱스 컬럼에 범위 검색 조건을 남용하면 인덱스 스캔 비효율이 발생합니다.

### [범위 검색 조건에 대한 비효율 - OR 조건 활용]

인덱스 선두 컬럼에 대한 옵션 조건에 OR 조건을 사용해선 안됩니다.

OR 조건을 활용한 옵션 처리 가능 상황

- 인덱스 액세스 조건으로 사용 불가
- 인덱스 필터 조건으로도 사용불가
- 테이블 필터 조건으로만 사용 가능
    
    → 인덱스에 포함되지 않은 컬럼에 대한 옵션 조건을 테이블에서 필터링해야 하므로 OR을 사용해도 된다.
    

OR 사용시의 유일한 장점은 NULL 허용 컬럼이더라도 결과집합을 보장합니다.

### [범위 검색 조건에 대한 비효율 - LIKE/BETWEEN 조건 활용]

변별력이 좋은 필수 조건이 있는 상황, 필수 조건 컬럼을 인덱스 선두에 두고 액세스 조건으로 사용하면 필터 조건으로 좋은 성능을 낼 수 있습니다.

하지만, 필수 조건의 변별력이 좋지 않은 경우에는 사용하면 안 됩니다.

LIKE/BETWEEN 조건을 활용한 옵션 처리 가능 상황

- 인덱스 선두 컬럼 X
- NULL 허용 컬럼 X
    
    → 성능을 떠나 결과 집합에 오류가 생깁니다. (NULL인 데이터는 결과집합에서 누락)
    
- 숫자형 컬럼(LIKE) X
    
    → 자동 형변환으로인해 필터 조건이 되기 때문에 옵션 조건으로 사용이 불가합니다.
    
- 가변 길이 컬럼(LIKE) X
    
    → 옵션 조건에 사용할 때는 컬럼 값 길이가 고정적이어야 합니다.
    
    → 가변적일때는 변수 값 길이가 같은 레코드만 조회되도록 조건절을 추가해야 합니다.
    

### [범위 검색 조건에 대한 비효율 - UNION ALL 조건 활용]

UNION ALL는 SQL 중 하나만 실행되게 하는 방식입니다.

옵션 조건 컬럼도 인덱스 액세스 조건으로 사용합니다.

NULL 허용 컬럼이더라도 사용하는 데 문제가 없지만 단점은 SQL 코딩량이 길어진다는 점입니다.

### [범위 검색 조건에 대한 비효율 - NVL/DECODE 조건 활용]

NVL과 DECODE는 실행계획이 똑같습니다.

장점은 옵션 조건 컬럼을 인덱스 액세스 조건으로 사용할 수 있습니다. 즉,  UNION ALL 보다 단순하면서도 UNION ALL과 같은 성능을 냅니다.

OR Expansion 쿼리 변환이 발생하기 때문에 인덱스 컬럼을 가공해도 인덱스 액세스 조건으로 사용이 가능합니다.

만약, 작동하지 않는다면 인덱스 액세스 조건으로 사용이 불가능합니다.

여러개를 사용하면 그중 변별력이 가장 좋은 컬럼 기준으로 한 번만 OR Expansion이 일어나기때문에 선택되지 않으면 필터 조건으로 사용 됩니다.

NVL/DECODE 조건을 활용한 옵션 처리 가능 상황

- NULL 허용 컬럼 X

### [함수호출 부하 해소를 위한 인덱스 구성]

PL/SQL 사용자 정의 함수는 개발자들이 일반적으로 생각하는 것보다 느립니다.

1. 가상 머신상에서 실행되는 인터프리터 언어
    
    → 작성한 함수가 컴파일 시 바이트 코드를 생성해 데이터 딕셔너리에 저장하면 가상머신으로 런타임 시 해석하면서 실행됩니다.
    
    → 네이티브 코드로 완전 컴파일된 내장 함수에 비해 느립니다.
    
2. 호출 시마다 컨텍스트 스위칭 발생
    
    → SQL 실행엔진과 PL/SQL 가상머신 사이에 컨텍스트 스위칭이 발생합니다.
    
3. 내장 SQL에 대한 Recursive Call 발생
    
    → DBMS 내부에서 발생하는 Call로 해당 함수 안에 존재하는 SQL문도 함수를 호출하는 SQL문과 같이 N번이 실행됩니다.
    

함수 호출 호출 횟수를 줄이는 방법이 있습니다.

액세스 조건을 고려한 인덱스 구성을 하여 함수가 단 한 번만 수행될 수 있도록 해야합니다.

## 인덱스 설계

인덱스가 많은면 구체적으로 아래와 같은 문제가 생깁니다.

- DML 성능 저하 (TPS 저하)
    
    → 인덱스 6 개가 달린 테이블에 신규 데이터 입력 시 여섯 개 인덱스에 데이터 입력 → 여유 공간 부족히 인덱스 분활 발생
    
- 데이터베이스 사이즈 증가(디스크 공간 낭비)
- 데이터베이스 관리 및 운영 비용 상승

### [설계 시 인덱스 스캔 효율성 판단 : 중요한 두 가지 선택 기준]

1. 조건절에 항상 사용하거나, 자주 사용하는 컬럼 선정한다.
2. 등치 조건으로 자주 조회하는 컬럼을 앞쪽에 둔다.

### [설계 시 인덱스 스캔 효율성 이외의 판단]

- 수행 빈도
- 업무상 중요도
- 클러스터링 팩터
- 데이터량
- DML 부하
- 저장 공간
- 인덱스 관리 비용

### [설계 시 인덱스 스캔 효율성 이외의 판단 : 수행 빈도]

수행빈도가 매우 높은 SQL에는 공식을 이용해 최적의 인덱스를 구성해 줘야 합니다.

테스트 과정에 당장 성능이 좋게 나오더라도 인덱스를 최적으로 구성해 줘야 합니다.

### [설계 시 인덱스 스캔 효율성 이외의 판단 : 데이터량]

테이블이 작어면 심각하게 고민할 이유는 없지만 초대용량 테이블일 때에는 전문가의 손길이 필요합니다.

### [공식을 초월한 전략적 설계]

최적을 달성해야 할 가장 핵심적인 액세스 경로 한두 개를 전략적으로 선택해서 최적 인덱스를 설계하고, 나머지 액세스 경로는 약간의 비효율이 있더라도 목표 성능을 만족하는 수준으로 인덱스를 구성할 수 있어야 합니다.

인덱스 스캔 효율보다 테이블 액세스가 더 큰 부하요소라는 점을 잊으면 안됩니다.

업무 상황을 고려한 전략적 판단을 통해, 사용빈도가 높거나 중요한 액세스 경로가 새로 도출됐을 때 최적의 인덱스를 추가할 여유가 생길 수 있습니다.

### [소트 연산을 생략하기 위한 컬럼 추가]

인덱스는 항상 정렬 상태를 유지하므로 ORDER BY, GROUP BY를 위한 소트 연산을 생략할 수 있게 도와줍니다.

즉, 조건절에 사용하지 않는 컬럼이더라도 소트 연산을 생략할 목적으로 인덱스 구성에 포함시킴으로써 성능 개선을 도모할 수 있습니다.

I/O를 최소화하면서도 소트 연산 생략 공식(순서 중요)

1. 등치조건 연산자로 사용한 조건절 컬럼 선정
2. ORDER BY 절에 기술한 컬럼 추가
3. 등치 연산자가 아닌 조건절 커럼은 데이터 분포를 고려해 추가 여부 결정
    
    → 조건을 만족하는 데이터가 적으면, 인덱스에 추가하는 것이 좋음
    

### [IN 조건은 =이 아니다]

IN 조건이 IN-List 방식으로 풀리게 되면 인덱스를 알맞게 설정하더라도 소트 연산을 생략하지 않습니다.

소크 연산을 생략하려면 IN 조건절을 액세스 조건으로 사용하면 안되고 필터 조건으로 사용해야 합니다.

### [결합 인덱스 선택도]

```
선택도
- 전체 레코드 중에서 조건절에 의해 선택되는 레코드 비율

카디널리티
- 선택도에 총 레코드 수를 곱한 값

인덱스 선택도
- 인덱스 컬럼을 모두 = 로 조회 시 평균적으로 선택되는 비율

인덱스 카디널리티
- 카디널리티  = 5 : 등치 조건으로 조회하면, 평균 5건이 조회된다는 뜻
```

선택도가 높은 인덱스는 테이블 액세스가 많이 발생하기 때문에 효용가치가 별로 없습니다.

인덱스를 생성할 때는 반드시 선택도/카디널리티를 확인해야 합니다.

### [결합 인덱스 선택도 :  컬럼 간 순서]

인덱스 생성 여부를 결정할 때는 선택도가 매우 중요하지만, 컬럼 간 순서를 결정할 때는 각 컬럼의 선택도보다 필수 조건 여부, 연산자 형태가 더 중요한 판단 기준입니다.
