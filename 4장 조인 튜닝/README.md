# 4장 조인 튜닝

## 1. NL 조인

```
NL 조인
- 소량 데이터를 주로 처리하거나 부분 범위 처리가 가능한 온라인 트랜잭션 처리 시스템에 적합한 조인 방식
```

1. 랜덤 액세스 위주의 조인 방식
    - 메모리 버퍼에서 빠르게 읽더라도 비효율 존재로 인덱스 구성 완벽해도 대량 데이터 조인 시 불리
2. 한 레코드씩 순차적으로 진행
    - 아무리 큰 테이블을 조인하더라도 매우 빠른 응답 속도 낼 수 있음 (부분범위 처리 활용)
3. 먼저 액세스 되는 테이블 처리 범위에 의해 전체 일량 결정
4. 다른 조인 방식과 비교할 때 인덱스 구성 전략이 특히 중요
    - 조인 컬럼에 대한 인덱스 존재 여부, 컬럼 구성에 따라 조인 효율 달라짐
5. OLTP 시스템에서 튜닝할 때 일차적으로 고려하는 NL 조인

### [기본 메커니즘]

NL 조인은 중첩 루프문과 같은 수행 구조를 사용합니다.

Outer와 Inner 양쪽 테이블 모두 인덱스를 사용하기 때문에 결국, NL 조인은 인덱스를 이용한 조인 방식이라고 할 수 있습니다.

- Outer : 사이즈가 크지 않으면 인덱스 이용 x 가능
- Inner : 인덱스 반드시 사용

### [실행계획 제어]

기본적으로 조인 순서는 옵티마이저가 스스로 정하지만 힌트를 사용한다면 조인 순서를 변경할 수 있습니다.

### [수행 과정 분석]

기본적으로 어떤 인덱스를 사용할지도 옵티마이저가 결정하지만 명시하면 변경 가능합니다.

### [튜닝 포인트]

1. OLTP 시스템에서 튜닝
    - 튜닝 시 일차적으로 NL 조인부터 고려
2. NL 조인 튜닝 포인트에서 각 단계의 수행 일량 분석해 과도한 랜덤 액세스가 발생하는 지점 파악
3. NL 조인으로 성능 내기 어렵다고 판단시 소트 머지 조인, 해시 조인으로 검토

### [NL 조인 확장 메커니즘]

읽는 블록마다 건건이 I/O Call을 발생시키는 비효율을 줄이기 위해 고안되었습니다.

```
테이블 Prefetch
- 인덱스를 이용해 테이블을 액세스하다가 디스크 I/O가 필요해지면, 이어서 곧 읽게 된 블록까지 미리 읽어 버퍼 캐시에 적재하는 기능

배치 I/O
- 디스크 I/O Call을 미뤘다가 읽을 블록이 일정량 쌓이면 한꺼번에 처리하는 기능
- 결과 집합의 정렬 순서가 보장되지 않습니다.
```

위 두 기능은 Inner 쪽 테이블 블록을 모두 버퍼캐시에서 읽는다면 어떤 방식이든 성능에 차이는 없고 데이터 출력 순서도 같습니다.

하지만, 일부를 디스크에서 읽게 되면 성능에 차이가 발생합니다.

## 2. 소트 머지 조인

```
소트 머지 조인
- 양쪽 집합을 정렬한 다음 NL 조인과 같은 방식으로 진행하는 조인
```

1. 조인을 위해 실시간으로 인덱스를 생성하는 것과 다름없음
2. 소트 부하만 감수한다면, 건건이 버퍼 캐시를 경우하는 NL 조인보다 빠름
    - PGA 영역에 저장한 데이터를 이용
3. 인덱스의 영향을 받지 않음
    - 인덱스가 없는 항상에서 테이블 읽어 조인 대상 집합을 줄일 수 있을 때 유리
4. 스캔 위주의 액세스 방식

### [SGA vs PGA]

```
SGA
- 공유 메모리 여역으로 여러 프로세스가 공유할 수 있지만, 동시에 액세스할 수 없습니다.
- 동시에 액세스하려는 프로세스 간 액세스를 직렬화하기 위한 Lock 메커니즘으로서 래치가 존재합니다.

PGA
- 오라클 서버에 각자 할당된 메모리 영역으로, 프로세스에 종속적인 고유 데이터를 저장하는 용도로 사용합니다.
- 공간이 작아 데이터를 모두 저장할 수 없을 떄는 Temp 테이블 스페이스를 이용합니다.
```

PGA는 독립적인 메모리 공간입니다. 

래치 메커니즘이 불필요하기 때문에 같은 양의 데이터를 읽더라도 SGA 버퍼캐시에서 읽을 때보다 훨씬 빠릅니다.

### [기본 메커니즘]

소트 머지 조인은 두 단계로 메커니즘이 진행됩니다.

1. 소트 단계 : 양쪽 집합을 조인 컬럼 기준으로 정렬한다.
    
    → 정렬한 결과 집합을 PGA 영역에 저장
    
2. 머지 단계 : 정렬한 양쪽 집합을 서로 머지한다.
    
    → 조인하는 과정은 NL 조인과 다르지 않음
    

NL 조인과 다른점은 데이터가 정렬돼 있으므로 조인 대상 레코드가 시작하는 지점을 쉽게 찾고, 조인에 실패하는 레코드를 만나는 순간 멈출 수 있습니다.

### [소트 머지 조인이 빠른 이유]

소트 머지 조인은 Sort Area에 미리 정렬해 둔 자료 구조를 이용한다는점만 다를 뿐 조인 프로세싱 자체는 NL 조인과 같습니다.

- NL 조인 : 인덱스를 이용한 방식이므로 읽는 모든 블록에 래치 획득 및 캐시버퍼 체인 스캔 과정을 거칩니다.
- 소트 머지 조인 : 양쪽 테이블로부터 조인 대상 집합을 일괄적으로 읽어 PGA에 저장한 후 조인을 하고 PGA는 독립적이기에 데이터에 대한 래치 획득 과정이 없습니다.

### [소트머지 조인의 주용도]

- 조인 조건식이 등치 조건이 아닌 대량 데이터 조인일 경우
    
    (등치 조건이면 해시조인을 사용할 수 있습니다.)
    
- 조인 조건식이 아예 없는 조인일 경우

### [실행계획 제어]

기본적으로 조인 순서는 옵티마이저가 스스로 정하지만 힌트를 사용한다면 조인 순서를 변경할 수 있습니다.

소트할 대상을 찾기 위해서 인덱스를 이용해 테이블을 액세스할 때도 있지만 Table Full Scan으로 처리 할 수도 있습니다.

## 3. 해시 조인

```
해시 조인
- 
```

1. 랜덤 액세스 부하가 없음
2. 양쪽 집합을 미리 정렬하는 부하가 없음
3. 해시 테이블을 생성하는 비용이 수반
    - 둘 중 작은 집합을 Build Input 으로 선택하므로 부담이 크지 않습니다.
4. 인메모리 해시 조인일 때 가장 효과적
5. 대용량 데이터 조인할 때는 일반적으로 가장 빠름

### [기본 메커니즘]

해시 조인은 두 단계의 메커니즘으로 진행됩니다.

1. Build 단계 : 작은 쪽 테이블을 읽어 해시 테이블을 생성합니다.
    
    → 조인 컬럼을 해시 테이블 키 값으로 사용합니다.
    
    → 해시 테이블은 PGA 영역에 저장됩니다.
    
2. Probe 단계 : 큰 쪽 테이블을 읽어 해시 테이블을 탐색하면서 조인합니다.
    
    → 컬럼을 해시 함수에 입력해 반환된 값으로 해시 체인을 찾고, 해시 체인을 스캔해 값이 같은 컬럼을 찾습니다.
    

### [해시 함수]

해시 함수는 Build 단계, Probe 단계에서 동일하게 사용합니다.

따라서, 해시 함수가 반환한 값에 해당하는 해시 체인만 스캔하면 됩니다.

### [해시 조인이 빠른 이유]

- NL 조인보다 빠른 이유
    - 해시 조인도 조인 프로세싱 자체는 NL 조인과 같지만 해시 테이블을 PGA 영역에 할당하기 때문에 빠릅니다.
- 소트머지 조인보다 빠른 이유
    - 조인 오퍼레이션을 시작하기 전 사전 준비작업에서 차이가 발생합니다.
    - 소트 머지 조인 : 양쪽 집합 중 하나가 중대형 이상이면 Temp 테이블 스페이스(디스크)에 I/O가 발생합니다.
    - 해시 조인 : 양쪽 집합 중 한쪽을 읽어 작읍 집합을 해시 맵으로 저장하므로 두 집합 모두 너무 큰 경우가 아니라면 TEmp 테이블 스페이스(디스크)에 I/O가 발생하지 않습니다.

### [대용량 Build Input 처리]

두 테이블 모두 대용량 테이블로 인메모리 해시 조인이 불가한 경우 분할&정복 방식을 사용합니다.

분활&정복 방식은 두 단계로 나눠 진행됩니다.

1. 파티션 단계
    
    ```
    파티셔닝
    - 테이블 또는 인덱스 데이터를 특정 컬럼 값에 따라 별도 세그먼트에 나눠 저장하는 방식
    ```
    
    - 조인하는 양쪽 집합의 조인 컬럼에 해시 함수를 적용 후, 반환된 해시 값에 따라 동적으로 파티셔닝
    - 독립적으로 처리 가능한 서브 집합으로 분활해 파티션 생성
2. 조인 단계
    - 각 파티션에 대해 하나씩 조인 수행
    - 각 파티션 짝에 대해 Build, Probe는 독립적으로 결정되기 때문에 테이블의 크기 상관없이 파티션 짝별로 작은 쪽이 Build로 선택되고 해시 테이블 생성
    - 반대쪽 파티션 로우를 하나씩 읽으며 해시 테이블 탐색

### [해시 조인 실행계획 제어]

Build Input을 옵티마이저가 선택하는데, 일반적으로 둘 중 카디널리티가 작은 테이블을 선택합니다.

이때, 각 테이블 조건절에 대한 카디널리티를 의미합니다.

이는 힌트로 Build를 사용자가 직접 선택할 수 있습니다.

## 조인 메소드 선택 기준

SQL 최적화 시 옵티마이저가 수행빈도까지 고려하지 않기때문에 매우 중요한 선택 기준입니다.

### [일반적인 선택 기준]

1. 소량 데이터 조인 → NL 조인
2. 대량 데이터 조인 → 해시 조인
3. 대량 데이터 조인이데 해시 조인으로 처리 불가 → 소트 머지 조인
    
    (조인 조건식이 등치 조건이 아닌 경우)
    

NL 조인 기준으로 최적화했는데도 랜덤 액세스가 많아 만족할만한 성능을 낼 수 없다면, 대량 데이터 조인입니다.

### [수행빈도가 매우 높은 쿼리에 대한 선택 기준]

1. NL 조인과 해시 조인 성능이 같음 → NL 조인
2. 해시 조인이 약간 더 빠름 → NL 조인
3. NL 조인보다 해시 조인이 매우 빠른 경우 → 해시 조인
    
    (결국엔 대량 데이터 조인인 경우이다)
    

### [NL 조인을 가장 먼저 고려하는 이유]

NL 조인에 사용하는 인덱스는 영구적으로 유지하면서 다양한 쿼리를 위해 재사용하는 자료구조입니다.

하지만, PGA에 생성되는 해시 테이블은 조인이 끝나면 소멸하는 자료구조 입니다.

따라서 수행 시간이 짧으면서 수행빈도가 매우 높은 쿼리를 해시 조인으로 처리시 CPU와 메모리 사용률이 크게 증가합니다.

### [해시 조인 사용시 주의사항]

해시 조인은 세 가지 조건을 만족하는 SQL문에 사용합니다.

- 수행 빈도가 작음
- 쿼리 수행 시간이 오래 걸림
- 대량 데이터 조인

(결국 배치 프로그램, DW 등의 쿼리 특징)

## 4. 서브쿼리 조인

```
서브쿼리
- 하나의 SQL문 안에 괄호로 묶은 별도의 쿼리 블록
- 쿼리에 내장된 또 다른 쿼리
```

오라크 DBMS는 서브쿼리를 세 가지로 분류합니다.

1. 인라인 뷰
    - FROM 절에 사용하는 서브쿼리입니다.
2. 중첩된 서브쿼리
    - 결과집합을 한정하기 위해 WHERE 절에 사용한 서브쿼리 입니다.
3. 스칼라 서브쿼리
    - 한 레코드당 정확히 하나의 값을 반환하는 서브쿼리입니다.

### [서브쿼리 변환이 필요한 이유]

```
쿼리 변환
- 옵티마이저가 SQL을 분석해 의미적으로 동일하면서도 더 나은 성능이 기대되는 형태로 재작성하는 것
- 비용을 평가하고 실행계획을 생성하기에 앞서 사용자로부터 전달받은 SQL을 최적화해 유리한 형태로 변환하는 작업
```

옵티마이저는 쿼리 블록 단위로 최적화를 수행합니다.

하지만, 서브쿼리별로 최적화한 쿼리가 전체적으로도 최적화되었다고 말할 수는 없습니다.

### [서브쿼리와 메인쿼리]

부모와 자식이라는 종속적이고 계층적인 관계가 존재합니다.

- 서브쿼리는 메인쿼리에 종속되므로 단독으로 실행 불가
- 메인쿼리 건수만큼 값을 받아 반복적으로 필터링하는 방식으로 실행

### [서브쿼리 사용법 1 - 필터 오퍼레이션]

필터 오퍼레이션은 기본적으로 NL 조인과 처리 루틴이 같습니다.

**NL 조인과의 차이점**

- 필터는 메인 쿼리의 로우가 서브 쿼리의 로우와 조인에 성공하는 순간 진행을 멈추고, 메인 쿼리의 다음 로우를 처리합니다.
    
    (메인쿼리 결과집합이 서브쿼리 M쪽 집합 수준으로 확장 현상 막음)
    
- 필터는 캐싱기능을 갖습니다.
    
    (서브쿼리를 수행하기 전 캐시값(bool)을 확인)
    
- 메인쿼리에 종속되므로 조인 순서가 고정됩니다.
    
    (항상 메인쿼리가 드라이빙 집합입니다.)
    

### [서브쿼리 사용법 2 - 서브쿼리 Unnesting]

```
서브쿼리 Unnesting
- 메인과 서브쿼리 간의 계층구조를 풀어 서로 같은 레벳로 만들어 줌
```

서브쿼리를 Unnesting 하면 일반 조인문처럼 다양한 최적화 기법을 사용할 수 있습니다. (서브쿼리 그대로 두면  필터 방식)

서브쿼리를 Unnesting 하는 이유

- NL 세미조인 외에도 다양한 방식으로 실행될 수 있음
    
    (NL 세미조인 : NL조인과 같지만 조인에 성공하는 순간 진행을 멈추고 메인 쿼리의 다음 로우를 계속 처리하는 점만 다름)
    
- 조인 순서 맘대로 처리 가능
    
    (메인쿼리가 드라이빙 집합이 아닌, 서브 쿼리를 메인 쿼리 집합보다 먼저 처리 가능)
    
- 조인 형태로 변환 했을 때 필터 오퍼레이션보다 더 좋은 실행경로 찾을 가능성 높아짐

### [서브쿼리 기능 - 캐싱]

```
캐싱
- 쿼리 단위로 이루어지며, 쿼리를 시작할 때 PGA 메모리 공간을 할당하고, 쿼리를 수행하면서 공간을 채워나가며, 쿼리를 마치는 순간 공간을 반환
- 조인 횟수를 최소화하기 위해 입력 값과 출력 값을 내부 캐시에 저장
- 캐시에서 찾지 못할 때만 조인을 수행하며, 결과는 버리지 않고 캐시에 저장
```

스칼라 서브 쿼리 캐싱과 필터 서브쿼리 캐싱에서 사용하는 기능으로 캐싱 메서니즘은 조인 성능을 높이는데 큰 도움이 됩니다.

즉, 같은 조인이더라도 서브쿼리를 사용하면 캐싱 기능이 있게 되면서 속도가 줄어듭니다.

또한, SELECT-LIST에 사용한 함수에 스칼라 서브쿼리를 덧씌우면 캐싱 효과로 메인 쿼리결과 건수 보다 호출 횟수가 줄어들게 됩니다.

### [서브쿼리 기능 - Pusing]

```
Pusing
- 서브쿼리 필터링을 가능한 한 앞 단계에서 처리하도록 강제하는 기능
- Unnesting 되지 않은 서브쿼리에만 작동
```

대게 실행계획 상 맨 마지막 단계에 처리되지만 이를 사용하면 순서를 변경할 수 있습니다.

### [인라인 뷰(조인) 서브쿼리]

옵티마이저가 인라인 뷰 쿼리를 변환하지 않으면 뷰 쿼리 블록은 독립적으로 최적화합니다.

- 뷰 쿼리를 조인으로 변환 시(뷰머징) : NL 조인 수행 (뷰를 메인 쿼리와 머징하는 기능) → 대형 데이터의 경우 해시 조인으로 가능
    - 장점 : 인라인 뷰 안에서 메인 쿼리의 조건을 사용할 수 있음
    - 단점 : 부분범위 처리가 불가능 (조인에 성공한 전체 집합을 출력, group by 사용 불가)
- 뷰 쿼리를 조인으로 변환하지 않을 시(뷰머징X) : 뷰 쿼리 블록 독립적으로 최적화 (VIEW로 생성함)

### [인라인 뷰(조인) 기능 - Pushdown]

```
Pushdown
- 메인 쿼리를 실행하면서 조인 조건절 값을 건건히 뷰 안으로 밀어넣는 기능
```

뷰 쿼리를 조인으로 변환시 단점이였던 부분 범위 처리가 가능해 집니다.

이 기능은 뷰 쿼리를 변환하지 않았을 때 사용이 가능합니다.

### [스칼라 서브쿼리]

- 함수 : 함수 내 쿼리를 메인 쿼리 건수만큼 재귀적으로 반복 실행
- 스칼라 서브쿼리 : 메인쿼리 레코드마다 정확히 하는 값만 반환

스칼라 서브쿼리는 함수처럼 재귀적으로 실행하는 구조가 아니기 때문에 컨텍스트 스위칭 없이 메인쿼리와 서브 쿼리를 한 번에 실행합니다.

실행계획 표현방식은 nl 조인과 다르지만, 프로세싱 과정은 NL 조인과 같습니다. ( 근데 이제 캐싱 효과를 곁들인...)

### [스칼라 서브쿼리 튜닝 - 함수 감싸기]

SELECT-LIST에 사용한 함수를 스칼라 서브쿼리를 덧씌우면 호출 횟수 최소화가 가능합니다.

캐싱 효과가 발생하기 때문에 함수 내의 쿼리도 덜 수행됩니다.

### [스칼라 서브쿼리 캐싱]

스칼라 서브쿼리로 조인하면 오라클은 조인 횟수를 최소화하기 위해 입력값과 출력값을 내부 캐시에 저장합니다.

캐시에서 찾지 못할 떄만 조인을 수행하며, 결과는 버리지 않고 캐시에 저장해둡니다.

캐싱은 쿼리 단위로 이루어지며, 필터 서브쿼리 캐싱과 같은 기능입니다.

- 장점 : 조인 성능을 높이는데 큰 도움
- 단점 : 입력 값의 종류가 소수여서 해시 충돌 가능성이 작을 때 효과적 ( 반대의 경우 성능이 나빠짐)
    - 입력 값의 종류가 다수일 때 불필요한 캐시 탐색으로 일반 조인문 보다 느림
    - 함수를 서브쿼리로 감쌀 때도 입력값이 다수일때  캐싱 효과 떨어짐
    - 메인 쿼리 집합이 작은 경우 캐시 재사용성이 낮음 ( 쓰지도 않은 캐시를 할당해 값을 채웠다가 바로 버리기 때문에 성능 떨어짐)

### [스칼라 서브쿼리 - 두 개의 값]

스칼라 서브쿼리의 큰 제약이 두 개 이상의 값을 반환할 수 없기 때문에 두 개 이상의 값을 반환하기 위해선 다른 방법을 써야합니다.

- 구하는 값들 문자열로 결합 후, 바깥쪽 액세스 쿼리에서 SUBSTR 함수로 분리
    
    ```sql
    select substr(x, 1, 4), substr(x, 5, 6). substr(x, 7, 10)
    from (select e, (select a | b | c from temp1) as x from temp2);
    ```
    
- 인라인 뷰 사용 - Pushdown기능
    - 인라인 뷰로 변환해 사용하면 인라인 뷰의 단점 발생 가능하기 때문에 Pushdown 기능 함께 사용

### [스칼라 서브쿼리 Unnesting]

스칼라 서브쿼리를 NL  조인이 아닌 해시 조인으로 실행될 수 있도록 해주는 힌트입니다.
