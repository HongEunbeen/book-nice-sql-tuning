
# 1. SQL 파싱과 최적화

### [구조적, 집합적, 선언적 질의 언어]

```
SQL
- Structured Query Language의 줄임말로 기본적으로 구조적이고 집합적이고 선언적인 질의언어입니다.
```

하지만, 결과집합을 만든는 과정은 프로시저를 통해 절차적일수밖에 없습니다.

### [SQL 최적화]

```
SQL 최적화
- DBMS 내부에서 프로시저를 작성하고 컴파일해 실행 가능한 상태로 만든는 전 과정을 뜻합니다.
- 사용자가 SQL을 작성해 전달하면 DBMS는 SQL을 실행하기 전 최적화 과정을 거칩니다.
```

1. **SQL 파싱**
    
    SQL 파서가 SQL 파싱을 진행합니다.
    
    - 파싱트리 생성 : SQL문 개별 구성요소 분석해 파싱 트리 생성
    - Syntax 체크 : 문법적 오류 확인 (키워드, 사용 순서 등)
    - Semanitc 체크 : 의미상 오류 확인 ( 권한, 컬럼 등)
2. **SQL 최적화**
    
    옵티마이저가 시스템 및 오브젝트 통계정보를 바탕으로 실행경로 생성해 비교 후 효율적인 방법 선택합니다.
    
3. **로우 소스 생성**
    
    옵티마이저가 선택한 실행경로를 로우 소스 생성기가 실제 실행 가능한 코드, 프로시저 형태로 포맷팅합니다.
    

### [SQL 옵티마이저]

```
SQL 옵티마이저
- 사용자가 원하는 작업을 가장 효율적으로 수행할 수 있는 최적의 데이터 액세스 경로를 선택해 주는 DBMS의 핵심엔진
```

**SQL 최적화 단계에서 옵티마이저의 단계**

1. 쿼리를 수행하는 실행계획들을 찾아냅니다.
2. 미리 수집해 둔 오브젝트 통계, 시스템 통계 정보를 이용해 각 실행계획의 예상비용을 산정합니다.
3. 최저 비용을 나타내는 실행계획을 선택합니다.

### [실행계획과 비용]

```
비용
- 쿼리를 수행하는 동안 발생할 것으로 예상하는 I/O 횟수 또는 예상 소요시간을 표현한 값
```

옵티마이저가 이 실행 계획을 선택하는 근거는 비용입니다.

하지만, 어디까지나 예상 비용입니다.

즉, SQL 실행경로를 선택하기 위해 옵티마이저가 여러 통계정보를 활용해 계상해 낸 값입니다.

### [옵티마이저 힌트]

```
옵티마이저 힌트
- 데이터 액세스 경로를 바꿈
```

SQL 옵티마이저는 대부분 좋은 선택을 하지만, 완벽하지 않기에 개발자가 직접 더 효율적인 액세스 경로를 찾아낼 수 있습니다.

옵티마이저 힌트를 이용해 액세스 경로를 바꿀 수 있습니다.

애플리케이션 환경에 따라 옵티마이저 실수에 큰 손실이 있다면 힌트를 사용해야 하고 힌트를 사용할거면, 빈틈없이 기술해야 합니다.

# 2. SQL 공유 및 재사용

### [소프트파싱 vs 하드 파싱]

```
라이브러리 캐시
- 내부 프로시저를 반복 재사용할 수 있도록 캐싱해 두는 메모리 공간
- SGA 구성 요소
```

```
SGA(System Global Area)
- 서버 프로세스와 백그라운드 프로세스가 공통으로 액섹스하는 데이터와 제어 구조를 캐싱하는 메모리 공간
```

- 소프트 파싱 : SQL을 캐시에서 찾아 곧바로 실행단계로 넘어가는 것
- 하드 파싱 : 캐시에서 찾지 못해 최적화 및 로우 소스 생성 단계까지 모두 거치는 것

SQL 최적화 과정은 하드합니다.

옵티마이저는 테이블 구조에 관한 기본 정보, 오브젝트 통계, 시스템 통계, 옵티마이저 관련 파라미터 등 정보를 가지고 각각에 대한 효율성을 판단하기에 결코 가벼울 수 없습니다.

이렇게 찾아낸 하드 파싱을 한 번만 사용하고 버리지 않고 라이브러리 캐시에 저장합니다.

라이브러리 캐시는 캐시 공간이 부족하면 버려졌다가 다음에 다시 실행할 때 똑같은 최적화 과정을 거쳐 캐시에 적재됩니다.

### [바인드 변수의 중요성]

SQL은 이름이 없기 때문에 전체 SQL 텍스트가 이름역할을 대신합니다.

사용자 정의 함수/프로시저는 이름이 변하지 않으므로 무한 생성되지 않아 영구 저장할 수 있습니다.

하지만, SQL은 자체가 이름이기 때문에 작은 부분이라도 수정되면 다른 객체로 새로 생성됩니다.

일회성 또는 무효화된 SQL까지 모두 저장하면 공간과 속도의 문제점이 있기때문에 DBMS는 SQL을 영구 저장하지 않고 캐시에 별도로 저장해 사용합니다.

라이브러리 캐시에서는 SQL 문 그 자체가 키 값입니다.

```sql
SELECT * FROM emp WHERE empno = 7900;
select * from emp where empno = 7900;
```

의미적으로는 같지만 각각 별도의 공간으로 사용됩니다.

### [SQL 하드 파싱]

```sql
string sql = "SELECT * FROM CUSTOMER WHERE LOGIN_ID ='" + login_id + "'";
```

이 쿼리는 각 요청에 대해 동시다발적으로 SQL 하드 파싱이 발생합니다. 즉, 라이브러리 캐시에 SQL 옵티마이저와 로우 소스 생성기가 내부 프로시저를 하나하나 만들어 적재하기 때문에 부하가 생깁니다.

```sql
string sql = "SELECT * FROM CUSTOMER WHERE LOGIN_ID = ?";
```

따로 프로시저 하나를 생성해서 공유하면서 재사용하는 것이 더 바람직합니다.

## 3. 데이터 저장 구조 및 I/O 메커니즘

### [SQL이 느린 이유]

```
SQL이 느린 이유 : 디스크 I/O
```

하나의 CPU는 하나의 프로세스만 처리합니다.

```
프로세스
-  실행중인 프로그램으로 생명주기가 있다.
```

I/O를 처리하는 동안 프로세스는 수명 상태에서 I/O가 완료되기를 기다립니다.

다른 프로세스들과 경합해 자원르 할당받은 프로세스가 일해야 하는 시간에 대기하는 것입니다.

바로 수많은 프로세스에 의해 동시다발적으로 발생하는 I/O Call 때문에 디스크 경합이 심대지고 대기 시간이 늘어나게 되어 SQL이 느려집니다.

### [데이터베이스 저장 구조]

![Untitled](https://github.com/HongEunbeen/book-nice-sql-tuning/blob/main/image/01.png)

```
데이터 파일
- 디스크 상의 물리적인 OS 파일

테이블 스페이스
- 세그먼트를 담는 콘테이너로 여러 개의 데이터파일(디스크 상의 물리적인 OS 파일)로 구성

세그먼트
- 테이블, 인덱스처럼 데이터 저장공간이 필요한 오브젝트

익스텐트
- 세그먼트의 공간을 확장하는 단위로 공간이 부족해지면 해당 오브젝트가 속한 테이블스페이스로부터 추가로 할당 받을 수 있다.
- 연속된 블록들의 집합

데이터 블록(페이지)
- 사용자가 입력한 레코드를 실제로 저장하는 공간
- 데이터를 읽고 쓰는 단위
```

**세그먼트 공간 부족으로 익스텐스 추가 할당**

세그먼트에 할당된 모든 익스텐트가 같은 데이터 파일에 위치하지 않을 수 있습니다. 파일 경합을 줄이기 위해 DBMS가 가능한 여러 데이터 파일로 분산해서 저장합니다.

### [블록 단위 I/O]

```
DBMS가 데이터를 읽고 쓰는 단위(데이터 I/O) : 데이터 블록
```

데이터 I/O 단위가 블록이므로 하나의 레코드를 읽을 때도 블록을 통째로 읽습니다.

테이블 뿐 아니라 인덱스도 블록 단위로 데이터를 읽고 씁니다.

### [시퀀셜 액세스 VS 랜덤 액세스]

```
테이블, 인덱스 블록을 읽는 방식
1. 시퀄셜 액세스 2. 랜덤 액세스

시쿼셜 액세스
- 논리적 또는 물리적으로 연결된 순서에 따라 차례대로 불록을 읽는 방식

랜덤 액세스
- 논리적, 물리적인 순서에 따르지 않고, 레코드 하나를 읽기 위해 한 블록씩 접근하는 방식

```

1. 시퀀셜 액세스
    
    테이블 블록 간에는 논리적인 연결고리를 갖고 있지 않지만 세그먼트에 할단된 익스텐트 목록을 세그먼트 헤더에 맵으로 관리합니다.
    
2. 랜덤 액세스

### [DB 버퍼 캐시]

DBMS에는 자주 읽는 블록을 매번 디스크에서 읽는 것은 비효율적이기 때문에 데이터 캐싱 메커니즘이 필수입니다.

```
라이브러리 캐시
- SQL과 실행계획, DB 저장형 함수/프로시저 등을 캐싱하는 코드 캐시

DB버퍼 캐시
- 디스크에서 읽은 데이터 블록을 캐싱하는 데이터 캐시
```

DB버퍼 캐시는 같은 블록에 대한 반복적인 I/O Call을 줄이 것이 목적입니다. 

또한, 공유 메모리 영역이므로 같은 블록을 읽는 다른 프로세스도 이득을 봅니다.

동작방법은 서버 프로세스와 데이터 파일 사이에 있으며 데이터 블록을 읽을 땐 항상 DB버퍼 캐시부터 탐색합니다.

### [논리적I/O vs 물리적 I/O]

```
논리적 블록 I/O
- SQL문을 처리하는 과정에서 메모리 DB버퍼캐시에서 발생한 총 블록 I/O

물리적 블록 I/O
- SQL문을 처리하는 과정에서 디스크에서 발생한 총 블록 I/O
```

SQL을 수행하면서 읽은 총 블록 I/O가 논리적 I/O입니다.

즉, 모든 블록은 DB버퍼 캐시를 경우해 읽기때문에 논리적 I/O 횟수는 DB 버퍼캐시에서 읽은 횟수와 일치합니다.

DB버퍼 캐시에 없어서 디스크를 읽은 블록 I/O가 물리적 I/O로 실행할 때마다 다르게 나타납니다.

```
버퍼캐시 히트율(BCHR)
- DB버커 패시 효율을 측정하는 데 전통적으로 가장 많이 사용하는 지표
- 전체 블록 중에서 물리적인 디스크 I/O를 수반하지 않고 곧바로 메모리에서 찾은 비율 나타냄
- BCHR이 SQL의 성능을 좌우하지만, BCHR이 높다고 해서 효율적인 SQL을 의미하지는 않습니다.
```

물리적 I/O가 성능을 결정하비만, 실제 SQL 성능이 향상하려면 물리적 I/O가 아닌 논리적 I/O를 줄여야 합니다.

물리적 I/O는 결국 시스템 상황에 의해 통제가 불가능하므로 SQL 성능을 높이기 위해선 논리적 I/O를 줄여야 합니다.

```
BCHR 공식
물리적 I/O : 통제 불가능한 외생 변수
논리적 I/O : 통제 가능한 내생 변수
```

→ 즉, SQL을 튜닝해서 논리적 I/O를 줄이면 물리적 I/O도 줄고, 그만큼 성능이 향상됩니다.

### [Single Block I/O vs Multiblock I/O]

DB버퍼 캐시에서 찾지 못한 데이터 블록을 I/O Call을 통해 디스크에서 DB버퍼 캐시로 적재하고자 요청할 때 방식입니다.

```
Single Block I/O
- 한 번에 한 블록씩 요청해서 메모리에 적재하는 방식

Multiblock I/O
- 한 번에 여러 블록씩 요청해서 메모리에 적재하는 방식
```

1. Single Block I/O
    - 인덱스를 이용할 때 기본적으로 모두 Single Block I/O 방식을 사용하고 소량의 데이터를 읽을 때 효율적입니다.
2. Multiblock I/O
    - Multiblock I/O는 캐시에서 찾지 못한 특정 블록을 읽으려고 I/O Call 할때 디스크 상에 그 블록한 인접한 블록을 한꺼번에 읽어 DB버퍼 캐시에 적재합니다.
        
        → 인접한 블록이란 같은 익스텐트에 속한 블록으로 경계를 넘지는 못합니다.
        
    - 많은 데이터 블록을 읽을 때나 인덱스를 이용하지 않고 전체 스캔할 때 사용합니다.
    - DB버퍼 캐시에서 블록을 찾지 못하면 디스크에서 읽기 위해 I/O Call을 하면 프로세스는 대기 상태가 되어 기와 대기하는 김에 많은 양을 요청해 횟수를 줄이고 성능을 높일 수 있습니다.
    - 한 번에 많은 데이터를 가져와야 유리합니다.

### [Table Full Sacn vs Index Range Scan]

```
테이블에 저장된 데이터를 읽는 두 가지 방식

Table Full Sacn
- 테이블에 속한 블록 전체를 읽어서 사용자가 원하는 데이터를 찾는 방식

Index Range Scan
- 인덱스에서 일정량을 스캔하면서 얻은 ROWID로 테이블 레코드를 찾아가는 방식

ROWID 
- 테이블 레코드가 디스크 상에 어디 저장됐는지를 가리키는 위치 정보
```

1. Table Full Sacn
    - 시퀄셜 액세스와 Multiblock I/O방식으로 디스크 블록을 읽습니다.
    - 스토리지 스캔 성능이 좋아지는 만큼 성능이 좋아집니다.
2. Index Range Scan
    - 랜덤 액세스와 Single Block I/O 방식으로 디스크 블록을 읽습니다.
    - 읽었던 블록을 반복해서 읽는 비효율이 있습니다.

### [캐시 탐색 메커니즘]

모든 블록 I/O 는 메모리 DB버퍼 캐시를 경유합니다.

```csharp
DB버퍼 캐시 탐색 메커니즘
- DBMS에서 해시 구조와로 관리하는 메커니즘
- DB버퍼 캐시에서 블록을 찾을 때 해시 알고리즘으로 버퍼 헤더를 찾고, 찾은 포인터로 버퍼 블록을 액세스 하는 방식
```

- 같은 입력 값을 항상 동일한 해시 체인에 연결됨
- 다른 입력 값이 동일한 해시 체인에 연결될 수 있음
- 해시 체인 내에서는 정렬이 보장되지 않음

### [직렬화 메커니즘]

```csharp
직렬화 메커니즘(줄세우기)
- 자원을 공유하는 것 처럼 보여도 내부에선 한 프로세스씩 순차적으로 접근하도록 구현
```

DB버퍼 캐시에 캐싱된 버퍼블록은 공유자원이므로 모두에게 권한이 있고 누구나 접근 가능합니다.

하지만, 두 개 이상의 프로세스가 동시에 접근하려면 블록 정합성에 문제가 발생할 수 있어 직렬화 메커니즘을 사용합니다.

### [래치 메커니즘]

```csharp
래치 메커니즘
- 특정 순간에 한 프로세스만 사용 가능하기에 다른 프로레스의 줄서기가 가능하도록 지원
```

해시 체인을 스캔하는 동안 다른 프로세스가 체인 구조를 변경하는 일을 막기 위해 해시 체인 래치가 존재합니다.

DB버퍼 캐시에는 개시버퍼 체인 래치, 캐시 버퍼 LRU 체인 래치 등이 작동합니다.

래치에 의한 경합이 생길 수 있어 캐시 I/O도 생각만큼 빠르지 않을 수 있습니다.

직렬화 메커니즘에 의해 캐시 경합을 줄이려면, SQL 튜닝르 통해 쿼리 일량 자체를 줄여야 합니다.

### [버퍼 LOCK]

버퍼블록 자체에도 직렬화 메커니즘이 존재하고, 캐시 버퍼 체인 래치를 해제하기 전 버퍼 헤더에 LOCK을 설정해 퍼버 블록 자체에 대한 직렬화 문제를 해결하는 것입니다.
