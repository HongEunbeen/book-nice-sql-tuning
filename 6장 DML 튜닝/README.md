## 기본 DML 튜닝

### [DML 성능에 영향을 미치는 요소]

- 인덱스
- 무셜성 제약
- 조건절
- 서브쿼리
- Redo 로깅
- Undo 로깅
- Lock
- 커밋

### [인덱스]

- 테이블에 레코드 입력 = 인덱스 입력
    - 테이블 : Freelist(테이블마다 데이터 입력이 가능한 블록 목록) 블록 할당받음
    - 인덱스 : 정렬된 자료구조로 수직적 탐색을 통해 입력할 블록 찾아 할당받음
- 삭제, 업데이트 시에도 인덱스는 과정이 더 복잡함
- 인덱스 개수가 DML 성능에 미치는 영향이 매우 크기에 설계가 가장 중요
    - 핵심 트랜잭션 테이블에서 인덱스 하나라도 줄이면 TPS는 그만큼 향상

### [무결성 제약]

- 논리적으로 의미있는 자료만 저장하게 하는 데이터 무결성 규칙
    - 개체 무결성
    - 참조 무결성
    - 도메인 무결성
    - 사용자 정의 무결성

→ DBMS에서 제약을 설정하면 더 완벽하게 데이터 무결성 지킬 수 있음 (애플리케이션에서도 가능)

- PK, FK 제약은 다른 제약에 비해 성능에 영향 크게 미침
    - PK, FK :  실제 데이터를 조회해야함
    - Check, Not Null : 정의한 제약 조건을 준수하는지만 확인하면 됨

### [Redo 로깅]

- Redo 로그 : 오라클에서 데이터파일과 컨트롤 파일에 가해지는 모든 변경사항을 기록
- DML 수행할 때 마다 Redo 로그를 생성해야 함 → DML에 영향 미침
    - INSERT 작업에서는 Redo 로깅 생략 기능을 제공함

### [Undo 로깅]

- Redo : 느랜잭션을 재현함으로써 과거의 현재 상태를 되돌리는 데 사용
    - 트랜잭션을 재현하는데 필요한 정보 로깅
- Undo : 트랜잭션을 롤백함으로써 현재를 과거 상태로 되돌리는 데 사용
    - 변경된 블록을 이전 상태로 되돌리는데 필요한 정보 로깅
    - DML을 수행할 때마다 Undo 생성 필요 ⇒ DML 성능에 영향을 미침
    - 오라클은 Undo를 안 남기는 방법을 아예 제공하지 않음

### [Lock]

- Lock을 필요 이상으로 자주, 길게 사용하거나 레벨을 높일수록 DML 성능은 느려짐
- Lock을 너무 적게, 짧게 사용하거나 필요한 레벨 이하로 낮추면 데이터 품질이 나빠짐
- 세심한 동시성 제어로 DML 성능과 데이터 품질을 관리해야함
    - 동시성 제어 : 동시에 실행되는 트랜잭션 수를 최대화하면서도 입력, 수정, 삭제, 검색 시 데이터 무결성을 유지하기 위해 노력하는 것

### [커밋]

- 커밋은 DML과 별개로 실행하지만, DML을 끝내려면 커밋까지 완료해야함
- 모든 DBMS가 Fast Commit을 구현하고 있음 → Fast Commit으로 커밋을 순간적으로 처리하지만, 커밋은 가벼운 작업이 아님

### [커밋의 내부 메커니즘]

- DB 버퍼캐시
- Redo 로그버퍼
- 트랜잭션 데이터 저장 과정
- 커밋 = 저장 버튼

## 데이터베이스 Call과 성능

### [SQL의 실행 단계]

- SQL은 세 단계로 나누어 실행됨
- Parse Call : SQL 파싱과 최적화를 수행하는 단계
    - SQL과 실행계획을 라이브러리 캐시에서 찾으면, 최적화 단계 생략 가능
- Execute Call : SQL을 실행하는 단계
    - DML은 이 단계에서 모든 과정이 끝나야함! → SELECT문은 Fetch에서 실행
- Fetch Call : 데이터응 읽어 사용자에게 결과집합을 전송하는 과정으로 SELECT 시에만 발생

### [Call 발생 시기에 따른 분류]

- User Call : 네트워크를 경유해 DBMS 외부로부터 인입되는 Call
    - 3-Tire 아키텍처에서 User Call은 WAS 서버에서 발생하는 Call
- Recursive Call : DBMS 내부에서 발생하는 Call
    - SQL 파싱과 최적화 과정에서 발생하는 데이터 딕셔너리 조회, PL/SQL로 작성한 사용자정의 함수, 프로시저, 트리거에 내장된 SQL 실행시 발생하는 Call

→ 둘 다, SQL을 실행할 때마다 Parse, Execute, Fetch Call 단계를 거침

### [Call 부하 줄이는 법]

- DB Call이 많으면 성능은 느려짐
    - 네트워크를 경우하는 User Call이 성능에 많은 영향을 미침
- One SQL
- Array Processing

### [One SQL]

```sql
insert into target
select * from source;
```

- 단 한 번의 Call로 처리하게 되면 속도는 빨라짐
    - 업무 로직이 복잡하면 절차적으로 처리할 수 밖에 없지만, 가급적 One SQL로 구현하려고 노력해야함
- 절차적 구현된 프로그램을 One SQL로 구현 방법
    - Insert Into Select
    - 수정가능 조인 뷰
    - Merge 문

### [Array Processing]

- Array Processing 기능을 활용하면 복잡한 업무 로직에서 One SQL을 구현하지 않고 Call 부하 줄일 수 있음
- 배열에 값을 넣어놓고 N 번에 한 번씩 INSERT 하도록 구현 → Call을 줄임
    - Array Processing을 활용해 One SQL에 준하는 성능 효과를 얻을 수 있음

## 인덱스와 무결성 제약 조건 → 배치로 해결

- 인덱스와 무결성 제약 조건의 DML 성능 저하는 배치 프로그래믕로 개선 가능

### [PK 제약과 인덱스 해제 1 - PK 제약에 Unique 인덱스를 사용한 경우]

- PK 제약을 비활성화하면서 인덱스를 Drop (Unusable 상태로 변환) 후 INSERT
- INSERT가 완료 된 후pk 제약을 활성화하고 일반 인덱스를 재생성

### [PK 제약과 인덱스 해제 2 - PK 제약에 Non-Unique인덱스를 사용한 경우]

- PK 인덱스는 제약을 비활성화하면서 Drop해야함
    - PK 인덱스는 Unusable 상태에서 데이터를 입력할 수 없음
- PK 인덱스를 Unuwable 상태에서 데이터를 입력하고 싶다면, Non-Unique 인덱스 사용하기

## Direct Path I/O 활용

- 배치 프로그램, 정보계 시스템 등 대량 데이터 SQL은 버퍼캐시를 경우하지 않고 곧바로 데이터 블록을 읽고 쓸 수 있는 Direct Path 기능 제공

### [Direct Path I/O]

- 버퍼 캐시 : 자주 읽는 블록에 대한 반복적인 I/O Call을 줄임으로써 시스템 전박적인 성능을 높이려고 사용
    - 읽고자 하는 블록을 번저 버퍼캐시에서 찾음 → 찾지 못할 때만 디스크 읽음
    - 데이터 변경시에도 버퍼캐시에서 찾고 변경을 가하면 DBWR 프로세스가 변경된 블록을 주기적으로 찾아 데이터 파일에 반영
- 대용량 데이터 버퍼캐시에서 읽을 때 단점
    - 대용량 데이터 재사용성이 낮음
    - 대용량 데이터가 버퍼캐시 점유시 다른 프로그램 성능도 나빠짐
- Direct Path I/O 기능이 작동하는 경우
    - 병렬 쿼리로 Full Scan을 수행할 떄
    - 병렬 DML을 수행할 때
    - Direct Path Insert 를 수행할 때
    - Temp 세그먼트 블록들을 읽고 쓸 때
    - direct 옵션을 지정하고 export를 수행할 때
    - nocache 옵션을 지정한 LOB 컬럼을 읽을 때

### [Direct Path Insert]

- 일반적인 INSERT 방법
    1. 데이터를 입력할 수 있는 볼록에서 Freelist를 찾음
    2. Freelist에서 할당받은 블록을 버퍼캐시에서 찾음
    3. 버퍼캐시에 없으면, 데이터파일에서 읽어 버퍼캐시에 적재
    4. INSERT내용을 Undo 세그먼트에 기록
    5. INSERT내용을 Redo 로그에 기록
- Direct Path Insert 방법
    1. INSERT SELECT 문에 append 힌트 사용
