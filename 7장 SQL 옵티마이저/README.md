## 통계정보와 비용 계산 원리

- 옵티마이저가 통계정보를 이용해 비용을 계산하는 원리

### [선택도와 카디널리티]

- 선택도(Selectivity) : 전체 레코드 중에서 조건절에 의해 선택되는 레코드 비율
    - NDV :  컬럼 값 종류 개수(Number of Distinct Values)
    
    ```
    선택도 = 1 / NDV
    ```
    
- 카디널리티(Cardinality) : 전체 레코드 중에서 조건절에 의해 선택되는 레코드 개수
    
    ```
    카디널리티 = 총 로우 수 * 선택도 = 총 로우 수 / NDV
    ```
    
- 옵티마이저는 카디널리티를 구하고, 그 만큼의 데이터를 액세스하는데 드는 비용을 계산해 조인 순서, 액세스 방식 등을 결정
    - 비용을 계산하는 출발점은 선택도!
    - 선택도를 계산할 때 NDV를 사용하므로 통계정보 수집 과정에서 이 값을 정확히 구해야함
        
        → 통계정보 수집주기, 샘플링 비율 등 결정 중요
        

## 통계 정보

- 오브젝트 통계
    - 테이블 통계
    - 인덱스 통계
    - 컬럼 통계(히스토그램)
- 시스템 통계

### [오브젝트 통계]

- 테이블 통계
    
    ```sql
    begin
    	dbms_stats.gather_table_stats('scott', 'emp' );
    end;
    /
    ```
    
- 인덱스 통계
    
    ```sql
    begin
    	dbms_stats.gather_index_state ( ownname => 'scott', indname => 'emp_x01');
    end;
    /
    ```
    
- 컬럼 통계
    - 테이블 통계 수집시 함께 수집
    
    ```sql
    select num_distinct, density, avg_col_len, low_value, high_value, num_nulls
    from all_tab_columns
    where owner = 'SCOTT'
    and table_name = 'EMP'
    and column_name = 'DEPTNO';
    ```
    
- 컬럼 히스토그램
    - 데이터 분포가 균일하지 않은 컬럼같은 경우 선택도를 구하기 위해 옵티마이저는 일반적인 컬럼 통계외에 히스토그램을 추가로 활용
    
    ```sql
    begin
    	dbms_stats.gather_table_state ( 'scott', 'emp', cascade=>false, method_opt=>'for colnumns ename size 10, deptno size 4');
    end;
    /
    ```
    
    - 오라클 12c에서 사용하는 히스토그램 유형으로 4가지
        - 도수분포 : 값별로 빈도수 저장
        - 높이균형 : 각 버킷의 높이 동일하도록 데이터 분포 관리
        - 상위도수분포 : 많은 레코드를 가진 상위 N개 값에 대한 빈도수 저장
        - 하이브리드 : 도수분포와 높이균형 히스토그램의 특성 결합

### [시스템 통계]

- 시스템 통계 : 애플리케이션 및 하드웨어 성능 특정을 측정한 것
    - CPU 속도
    - 평균적인 Single Block I/O 속도
    - 평균적인 Multiblock I/O 속도
    - 평균적인 Multiblock I/O 개수
    - I/O 서브 시스템의 최대 처리량
    - 병렬 Slave의 평균적인 처리량

```sql
select snmae, pname, pval1, pval2 from sys.aux_stats$;
```

→ 과거에는 시스템 사양, 애플리케이션 특성을 반영하지 않았지만 오라클은 9i부터 옵티마이저가 합리적으로 작동할 수 있도록 통계수집 기능 도입

## 비용 계산 원리

- 단일 테이블을 인덱스로 액세스할 때의 비용 계산 원리
    - 인덱스 키값을 모두 동등 조건으로 검색 시 인덱스 통계만으로 비용 구하기 가능
        
        ```sql
        비용 = BLEVEL -- 인덱스 수직적 탐색 비용
        	+ AVG_LEAF_BLOCKS_PER_KEY -- 인덱스 수평적 탐색 비용
        	+ AVG_DATA_BLOCKS_PER_KEY -- 테이블 랜덤 액세스 비용
        ```
        
    - 인덱스 키값이 모두 동등 조건이 아닐 시 컬럼 통계까지 활용
        
        ```sql
        비용 = BLEVEL -- 인덱스 수직적 탐색 이용
        	+ LEAF_BLOCKS * 유요 인덱스 선택도  -- 인덱스 수평적 탐색 비용
        	+ BLUSTERING_FACTOR * 유횽 테이블 선택도  -- 테이블 랜덤 액세스 비용
        ```
        
        - 유효 인덱스 선택도 : 전체 인덱스 레코드 중 액세스 조건에 의해 선택될 것으로 예상되는 레코드 비중
        - 유효 테이블 선택도 : 전체 인덱스 레코드 중 인덱스 컬럼에 대한 모든 조건절에 의해 선택될 것으로 예상되는 레코드 비중
- 비용(Cost)
    - 비용 계산시 : I/O 비용 모델 기준 = 예상 I/O Call 횟수 의미

## 옵티마이저에 대한 이해

- 옵티마이저 = 자동차 내비게이션

### [옵티마이저 종류]

- 비용기반 옵티마이저(CBO)
    - 사용자 쿼리를 위해 후보군이 될만한 실행계획 도출
    - 데이터 딕셔너리에 미리 수집해 둔 통계정보 이용해 각 실행계획의 비용 산정
    - 낮은 비용의 실행계획 하나를 선택
    - 사용하는 통계정보 : 데이터량, 컬럼 값의 수, 인덱스 높이 등
- 규칙기반 옵티마이저(RBO)
    - 각 액세스 경로에 대한 우선순위 규칙에 따라 실행계획 도출
    - 데이터 특성을 나타내는 통계 정보 활용 X + 단순한 규칙에 의존해 대량 데이터 처리 부적합
    - 사용하는 규칙 : 인덱스 구조, 연산자, 조건절 형태로 순위 결정
- RBO의 한계점
    - 부분 처리가 가능한 상황에서도 소트 연산을 생략하지 않음
    
    → CBO가 탄생하게 됨
    

→ 데이터와 시스템 특성을 고려해 정교한 통계정보 수집 정책을 수립함으로써 옵티마이저가 스스로 최적의 결정을 하도록 돕는 데 역량을 집중해야 함

### [옵티마이저 모드]

- 최적화 목표를 설정하는 기능으로서 세가지 옵티마이저 모드 존재
    - ALL_ROWS : 전체 처리속도 최적화
        - 쿼리 결과집합 전체를 읽는 것을 전제로 시스템 리소스를 가장 적게 사용하는 실행계획 선택
    - FIRST_ROWS : 최초 응답속도 최적화
        - 전체 결과집합 중 앞쪽 일부만 읽다가 멈추는 것을 전제로 응답 속도가 가장 빠른 실행계획 선택
        - 앞으로 사라지게 될 옵티마이저 모드
    - FIRST_ROWS_N : 최초 n건 응답속도 최적화
        - 사용자가 앞쪽 N개 로우만 읽고 멈추는 것을 전제로 응답 속도가 가장빠른 실행계획 선택
        - 읽을 데이터 건수를 지정해 더 정확한 비용 산정 가능

### [옵티마이저에 영향을 미치는 요소]

- SQL과 연산자 형태
    - 결과는 같아도 SQL 형태, 연산자 종류에 따라 옵티마이저가 다른 선택 가능
- 인덱스, IOT, 클러스터, 파티션, MV 등 옵티마이징 팩터
    - 쿼리를 같게 작성해도 인덱스, IOT, 클러스터, 파티션, MV 등 구성 정보에 따라 실행계획과 성능 달라짐
- 제약 설정
    - 제약들은 데이터 무결성을 보장 + 옵티마이저가 쿼리 성능을 최적화하는 데 매우 중요한 메타 정보로 활용
- 통계정보
    - 통계정보는 옵티마이저에 강력한 영향 미침
- 옵티마이저 힌트
    - 옵티마이저에게 가장 절대적인 영향을 미치는 요소
        - 힌트를 명령어로 인식하고 따름
    - 힌트가 작동하지 않을 시 주의할 점
        1. 문법적으로 맞지 않게 힌트를 기술
        2. 잘못된 참조 사용
        3. 의미적으로 맞지 않게 힌트를 기술
        4. 논리적으로 불가능한 액세스 경로
        5. 버그
- 옵티마이저 관련 파라미터
    - 모든 환경이 같아도 오라클 버전 업그레이드 시 옵티마이저 다르게 작동 가능
        
        → 파라미터 추가 또는 기본값 변경으로 발생
        
        ```sql
        --옵티마이저 행동에 영향을 미치는 파라미터 목록 쿼리
        select name, value, isdefault, default_value
        from v$sys_optimizer_env
        ```
        

### [옵티마이저의 한계]

- DBA가 통계정볼르 아무리 잘 수집하고 개발자가 SQL을 잘 작성해도 옵티마이저도 실수함
- 옵티마이저 행동에 가장 큰 영향을 미치는 통계정보를 필요한 만큼 충분히 확보 ⇒ 불가능
    - 통계정보를 수집하고 관리하는 데 비용 발생
- 통계정보가 완벽해도 바인드 변수를 사용한 SQL에 컬럼 히스토그램을 활용할 수 없다는 단점도 있음
- 기본적으로 비용기반으로 작동하지만, 내부적으로 여러 가정과 정해진 규칙을 이용해 기계적인 선택함 → 한계점
- 한계와 제약으로 앞으로도 옵티마이저는 불완전할 수밖에 없음

### [개발자의 역할]

- 불완전한 옵티마이저에만 의존할 것이 아닌 개발자 스스로 옵티마이저가 되어야 함
- 결과물이 올바른지 실행계획을 통해 점검하고, 개선할 여지는 없는지 찾는 노력 필요
- RDBMS 환경에서 SQL 성능을 높이기 위해 개발자가 할 일
    - 필요한 최소 블록만 읽도록 쿼리를 작성
        - 통계정보에 담기 힘든 업무적 특성까지 고려해 SQL을 작성하는 것은 개발팀 역할!
    - 최적의 옵티마이징 팩터를 제공
        - 옵티마이저가 최적화를 잘 할 수 있도록 수단을 제공해야함
        1. 옵티마이저 모드를 포함해 각종 파라미터를 적절한 값으로 설정하고, 통계정보를 잘 수집해 주는 것이 중요
        2. 전략적인 인덱스 구정
        3. DBMS가 제공하는 기능을 적극적으로 활용
    - 필요하다면, 옵티마이저 힌트를 사용해 최적의 액세스 경로로 유도
        - 옵티마이저는 생각만큼 완벽하지 않기때문에 최적의 액세스 경로를 찾아내고, 실행계획을 그 방식으로 유도할 수 있는 능력을 갖추어야 함

### [데이터베이스 튜닝]

- 데이터베이스 튜닝 : SQL이 병목이나 지연 없이 빠르고 안정적으로 수행되도록 조치하는 모든 활동
    - SQL 튜닝 : I/O 효율화, DB Call 최소화, SQL 파싱 최소화 등
    - DB 설계 : 논리적 데이터 구조 설계, 물리적 저장 구조 설계 등
    - 인스턴스 튜닝 : Lock/Latch 모니터링 및 해소, 메모리 설정, 프로세스 설정 등
