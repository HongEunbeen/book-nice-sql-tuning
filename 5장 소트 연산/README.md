## 1. 소트연산에 대한 이해

### [소트 수행 과정]

소트는 기본적으로 PGA에 할당한 Sort Area에서 이루어집니다.

- 메모리 소트 : 전체 데이터의 정렬 작업을 메모리 내에서 완료하는 것 = Internal Sort
- 디스크 소트 : 할당받은 Sort Area내에서 정렬을 완료하지 못해 디스크 공간까지 사용하는 경우 = External Sort

소트 연산은 메모리 집약적일 뿐만 아니라 CPU 집약적입니다.

→ 디스크 소트가 발생하는 순간 SQL 수행 성능은 나빠지고, 부분 범위 처리를 불가하게 함으로써 OLTP 환경에서 성능을 저하시킵니다.

### [소트 오퍼레이션]

- Sort Aggregate
    - 전체 로우를 대상으로 집계를 수행
    - 실제로 데이터를 정렬하진 않고 Sort Area를 사용하는 의미
    - `sum`, `max`, `min`, `count`등
- Sort Order By
    - 데이터를 정렬할 때
    - `order by`
- Sort Group By
    - 소팅 알고리즘을 사용해 그룹별 집계를 수행할 떄
    - `group by`
- Sort Unique
    - 옵티마이저가 서브쿼리를 풀어 일반 조인문으로 변환할 때 중복 레코드를 제거하면서 나타남
    - `Unnesting된 서브쿼리`, `Distinct`
- Sort Join
    - 소트 머지 조인을 수행 할 떄
- Window Sort
    - 윈도우 함수(분석 함수)를 수행할 떄
    - `avg() over()`

## 2. 소트가 발생하지 않도록 SQL 작성

- Union, Minus, Distinct 연산자는 중복 레코드를 제거하기 위한 소트 연산을 발생시키므로 꼭 필요한 경우에만 사용해야 합니다.

### [Union vs. Union All]

- Union : 상단과 하단 두 집합 간 중복 제거 위한 소트 작업 수행
- Union All : 중복을 확인하지 않고 두 집합 단순한 결합으로 소트 작업 수행 X

만약, 위 아래 두 집합이 상호 배타적이면 Union 대신 Union All 사용

→ 상호 배타적 = 위 아래 쿼리에서 조건절에 다른 값을 입력해 인스턴스의 중복 가능성이 없는 경우를 말함

상호배타적 관계가 아니면 Union을 사용해야 하지만 Union All을 사용하면서도 데이터 중복을 피하려면, 조건절을 추가하면 됨

```sql
select a
from table1
where a = 50
UNION ALL
select a, b
from table1
where a < 100 and a != 50
```

### [Exists 활용]

Distinct연산자를 사용하면 조건에 해당하는 데이터를 모두 읽어서 중복을 제거함

Exists 서브쿼리는 데이터 존재 여부만 확인하면 되기 떄문에 조건절을 만족하는 데이터를 모두 읽지 않음

→ Distinct, Minus 연산자를 사용한 쿼리는 대부분 Exists 서브쿼리로 변환이 가능합니다.

- Distinct → Exists
- Minus → Not Exists

### [조인 방식 변경]

NL 조인하도록 조인 방식을 변경하면 소트 연산을 생략할 수 있고 부분범위 처리 가능한 상황에서 큰 성능 개선 효과를 얻을 수 있습니다.

정렬 기준이 조인 키 컬럼이면 소트 머지 조인도 Sort Order By 연산을 생략할 수 있습니다.

## 3. 인덱스를 이용한 소트 연산 생략

인덱스 : 항상 키 컬럼 순으로 정렬된 상태 유지

→ Order By 또는 Group By절 있어도 소트 연산 생략 가능

→ Top N 쿼리 특성 결합하면, 빠른 응답 속도 가능

### [Sort Order By 생략]

소트해야 할 대상을 인덱스로 구성하면 SQL 문에 Order By 절이 있어도 옵티마이저가 Sort Order By를 생략합니다.

→ 이 원리로 부분범위 처리도 가능합니다.

### [3-tire 환경에서의 부분범위 처리]

WAS, AP 서버 등 존재하는 3-Tier 아키텍처는 서버 리소스를 수많은 클라이언트가 공유하는 구조이므로 클라이언트가 특정 DB 커넥션을 독점할 수 없습니다.

즉, 쿼리 결과 집합을 조금씩 나눠서 전송하는 방식(부분범위 처리)을 사용할 수 없습니다.

- 결과 집합 출력을 바로 시작할 수 있느냐
- 앞쪽 일부만 출력하고 멈출 수 있느냐

이 두 가지 부분이 핵심이므로 3-Tier 환경에서는 의미가 없을 수 있습니다. 

→  하지만, Top N 쿼리를 사용하면 3-Tier 환경에서도 부분범위 처리를 할 수 있습니다.

### [Top N 쿼리]

Top N 쿼리 : 전체 결과집합 중 상위 N개 레코드만 선택하는 쿼리

Top N Stopkey 알고리즘 : 조건절에 부합하는 레코드가 아무리 많아도 그 중 ROWNUM으로 지정한 건수만큼 결과 레코드를 얻으면 거기서 바로 멈춘다는 뜻

3-Tire 환경에서는 대량의 결과집합을 조회할 때 페이징 처리 기법을 활용합니다.

1. 부분 범위 처리 가능하도록 SQL을 작성한다.
2. 작성한 SQL 문을 페이징 처리용 표준 패턴SQL Body 부분에 붙여 넣는다.

→ 즉, 부분범위 처리가능하도록 인덱스 사용해 조건절을 구사하고, 조인은 NL 조인 위주로 처리하고, Order By 절이 있어도 소트 연산을 생략할 수 있도록 인덱스를 구성해 줘야 합니다.

### [페이징 처리 ANTI 패턴]

```sql
SELECT * 
FROM (
	SELECT ROWNUM no, a.*
	FROM 
	 (
		SELECT b,c,d from aa order by 
	 ) a
)
WHERE no BETWEEN (:page-1)*10 + and (:page * 10)
```

위 SQL은 간결하긴 하지만 안티패턴 입니다.

- Order By 아래 쪽 ROWNUM은 단순한 조건절이 아닌 Top N Stopkey 알고리즘을 작동하게 하는 열쇠인데 ROWNUM 조건절이 없어 Stopky 알고리즘을 수행하지 못하고 전체 범위를 처리하게 됩니다.

```sql
SELECT * 
FROM (
	SELECT ROWNUM no, a.*
	FROM 
	 (
		SELECT b,c,d from aa order by 
	 ) a
	WHERE rownum <= (:page * 10)
)
WHERE no >= (:page-1)*10 +1
```

위와 같이 처리해야 Stopkey 알고리즘이 수행됩니다.

### [최소값/최대값 구하기]

인덳느느 정려돼 있으므로 이를 이용하면 전체 데이터를 읽지 않고도 최소 또는 최대값을 쉽게 찾을 수 있습니다.

- 인덱스 맨 왼쪽 : 첫 번째 읽는 값이 최소값
- 인덱스 맨 오른쪽 : 첫 번째 읽는 값이 최대값

 인덱스 이용해 최소/최대값 구하기 조건

→ 조건절 컬럼과 MIN/MAX 함수 인자 컬럼이 모두 인덱스에 포함돼 있어야 합니다.

즉, 테이블 액세스가 발생하지 않아야 합니다.

조건절 컬럼과 MIN/MAX 컬럼이 모두 인덱스에 포함돼 있으므로 Frist Row Stopkey 알고리즘이 작동합니다.

Top N 쿼리 이용해 최소/최대값 구하기 

Top N 쿼리를 통해 `ROWNUM ≤ 1` 조건을 이용해 Top 1 레코드를 찹으면 최소 또는 최대값을 쉽게 구할 수 있습니다.

- Top N StopKey 알고리즘은 모든 컬럼이 인덱스에 포함돼 있지 않아도 잘 작동합니다.
- 장점 : 성능 측면에서는 MIN/MAX 쿼리보다 좋습니다.
- 단점 : 인라인 뷰를 사용하므로 쿼리가 약간 더 복잡해집니다.

### [Sort Group By 생략]

그룹핑 연산에도 인덱스를 활용하여 Nosoert 방식으로 Group By 연산을 처리하면 부분범위 처리가 가능해집니다.

## Sort Area를 적게 사용하도록 SQL 작성

소트연산이 불가피하다면 → 메모리 내에서 처리 완료할 수 있도록 노력해야합니다.

### [소트 데이터 줄이기]

소트한 데이터량이 많을수록 성능이 느려집니다.

가공한 결과집합을 Sort Area에 담는다면 Sort Area를 많이 사용하게 됩니다.

→ 가공하지 않은 상태에로 정렬을 완료하고 나서 최종 출력할 때 가공해야 합니다.

### [Top N 쿼리가 아닐 때 발생하는 소트 부하]

소트 연산을 피힐 수 없어 Sort Order By 오퍼레이션을 수행하지만 Top N 소트 알고리즘이 작동하는 방식입니다.

소트 연산 횟수와 Sort Area 사용량을 최소화 해줍니다.

```sql
select *
from (
	select rownum no ,a.*
	(
		select b,c,d from aa order by b
	) a
	where rownum <= (:page*10)
)
where  rownum >= (:page-1)*10 + 1
```

→ 이러한 방식으로 처리하면, 대상 집합이 아무리 커도 많은 메모리 공간이 필요하지 않고 전체 레코드를 다 정렬하지 않고도 오름차순으로 최소값을 갖는 열 개 레코드를 정확히 찾아낼 수 있습니다.

### [분석함수에서의 Top N 소트]

`rank`, `row_number`함수는 `max` 함수보다 Top N 소트 알고리즘 작동으로 소트 부하가 적습니다.
